// stdlib
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
// system
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
// C++
#include <vector>
#include <iostream>

using namespace std;

const size_t k_max_msg = 4096;

// Connection state.
struct Conn {
	int fd = -1;
	// application's intention, for the event loop
	bool want_read = false;
	bool want_write = false;
	bool want_close = false;
	// buffered input and output
	std::vector<uint8_t> incoming;  // data to be parsed by the application
	std::vector<uint8_t> outgoing;  // responses generated by the application
};

// Error handling functions.
static void die(const char *msg) {
	int err = errno;
	fprintf(stderr, "[%d] %s\n", err, msg);
	abort();
}

// Print a message to stderr.
static void msg(const char *msg) {
	fprintf(stderr, "%s\n", msg);
}

// Set a file descriptor to non-blocking mode.
static void fd_set_nb(int fd) {
	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}

// Append to the back of the buffer.
static void
buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len) {
	buf.insert(buf.end(), data, data + len);
}
// Remove from the front of the buffer.
static void buf_consume(std::vector<uint8_t> &buf, size_t n) {
	buf.erase(buf.begin(), buf.begin() + n);
}

static int32_t read_full(int fd, char *buf, size_t n) {
	while (n > 0) {
		errno = 0;
		ssize_t rv = read(fd, buf, n);
		if (rv <= 0) {
			if (errno == EINTR) { // interrupted by signal, not an error
				std::clog << "interrupted by signal" << std::endl;
				continue;
			}
			return -1;  // error, or unexpected EOF
		}
		assert((size_t)rv <= n);
		n -= (size_t)rv;
		buf += rv;
	}
	return 0;
}

static int32_t write_all(int fd, const char *buf, size_t n) {
	while (n > 0) {
		ssize_t rv = write(fd, buf, n);
		if (rv <= 0) {
			return -1;  // error
		}
		assert((size_t)rv <= n);
		n -= (size_t)rv;
		buf += rv;
	}
	return 0;
}

static int32_t one_request(int connfd) {
	// 4 bytes header
	char rbuf[4 + k_max_msg];
	// set errno to 0 before calling read_full
	errno = 0;
	int32_t err = read_full(connfd, rbuf, 4);
	if (err) {
		msg(errno == 0 ? "EOF" : "read() error");
		return err;
	}


	uint32_t len = 0;
	memcpy(&len, rbuf, 4);  // assume little endian
	if (len > k_max_msg) {
		msg("too long");
		cout << "len: " << len << endl;
		cout << rbuf << endl;
		return -1;
	}

	// request body
	err = read_full(connfd, &rbuf[4], len);
	if (err) {
		msg("read() error");
		return err;
	}
	// do something
	printf("client says: %.*s\n", len, &rbuf[4]);
	// reply using the same protocol
	const char reply[] = "world";
	char wbuf[4 + sizeof(reply)];
	len = (uint32_t)strlen(reply);
	memcpy(wbuf, &len, 4);
	memcpy(&wbuf[4], reply, len);
	return write_all(connfd, wbuf, 4 + len);
}

// Handle accept.
static Conn *handle_accept(int listen_fd) {
	struct sockaddr_in client_addr = {};
	socklen_t client_addr_len = sizeof(client_addr);
	int client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);
	if (client_fd < 0) {
		return nullptr; // error
	}

	// Set the client socket to non-blocking mode.
	fd_set_nb(client_fd);

	// Create a new connection state.
	Conn *conn = new Conn();
	conn->fd = client_fd;
	conn->want_read = true; // Read the first request.
	return conn;
}

// Try to parse the accumulated buffer.
static bool try_one_request(Conn *conn) {
	// Check if the accumulated buffer has at least 4 bytes, which is the size of the message header.
	if (conn->incoming.size() < 4) {
		return false; 
	}

	// Parse the message header.
	uint32_t len = 0; // Message length.
	memcpy(&len, conn->incoming.data(), 4); // Assume little endian.
	if (len > k_max_msg) { // protocol violation
		conn->want_close = true;
		return false; // return with want_close = true
	}

	if(4 + len > conn->incoming.size()) {
		return false;
	}

	// Process the parsed message.
	const uint8_t *request = &conn->incoming[4]; // Request body.

	printf("client says: len:%d data:%.*s\n",
		len, len < 100 ? len : 100, request);
	
	// Generate response.
	buf_append(conn->outgoing, (const uint8_t *)&len, 4);
	buf_append(conn->outgoing, request, len);
	// Remove the message from `Conn::incoming`.
	buf_consume(conn->incoming, 4 + len);
	return true;
}

// Handle read.
static void handle_read(Conn *conn) {
	uint8_t buf[64 * 1024]; // 64 KB buffer
	ssize_t rv = read(conn->fd, buf, sizeof(buf));
	if (rv <= 0) {
		conn->want_close = true;
		return; // return with want_close = true
	}

	// Append the read data to the `Conn::incoming` buffer.
	buf_append(conn->incoming, buf, (size_t)rv);

	try_one_request(conn);

	// If there is data to send, set the `want_write` flag.
	if (conn->outgoing.size() > 0) {
		conn->want_read = false;
		conn->want_write = true;
	} // else, keep `want_read` true
}

// Handle write.
static void handle_write(Conn *conn) {
	assert(conn->outgoing.size() > 0);

	// Write the response to the client.
	ssize_t rv = write(conn->fd, conn->outgoing.data(), conn->outgoing.size());
	if (rv <= 0) {
		conn->want_close = true;
		return; // return with want_close = true
	}

	// Remove the sent data from the `Conn::outgoing` buffer.
	buf_consume(conn->outgoing, (size_t)rv);

	// If there is no more data to send, set the `want_read` flag.
	if (conn->outgoing.size() == 0) {
		conn->want_read = true;
		conn->want_write = false;
	} // else, keep `want_write` true
}

// Main function.
int main()
{
	// Define listener socket.
	// AF_INET: IPv4 Internet protocols
	// SOCK_STREAM: TCP - connection-based protocol
	int listen_fd = socket(AF_INET, SOCK_STREAM, 0); // Listener socket file descriptor.
	if (listen_fd < 0) {
		die("socket()");
	}

	// Set the socket option to reuse the address.
	// This allows the server to bind to the same address and port. 
	int val = 1;
	int sockopt_rv = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
	if (sockopt_rv) {
		die("setsockopt()");
	}


	// Bind the socket to an address and port.
	struct sockaddr_in addr = {}; // IPv4 port pair.
	addr.sin_family = AF_INET;
	addr.sin_port = htons(1234);        // port
	addr.sin_addr.s_addr = htonl(0);    // wildcard IP 0.0.0.0
	int rv = bind(listen_fd, (const struct sockaddr *)&addr, sizeof(addr));
	if (rv) {
		die("bind()");
	}


	// Listen for incoming connections.
	rv = listen(listen_fd, 10);
	if (rv) {
		die("listen()");
	}

	// Since fd is a small integer, we can use a simple vector to map fd to connection state.
	std::vector<Conn *> fd2conn; // map file descriptor to connection state

	// Vector of pollfd structures.
	// Each pollfd structure contains the file descriptor and the events to monitor.
	std::vector<struct pollfd> poll_args;

	// Set the listener socket to non-blocking mode.
	fd_set_nb(listen_fd);
	// Event loop.
	while (true) {

		// Clear the poll_args vector.
		poll_args.clear();

		// Add the listener socket to the poll_args vector.
		struct pollfd listen_pollfd = {listen_fd, POLLIN, 0};
		poll_args.push_back(listen_pollfd);

		// Add the connection sockets to the poll_args vector.
		for(Conn *conn : fd2conn) {
			// Skip connections that are not active.
			if (!conn) {
				continue;
			}
			// Add the connection socket to the poll_args vector.
			struct pollfd pfd = {conn->fd, 0, 0};
			// Monitor the connection socket for read and write events.
			if (conn->want_read) {
				pfd.events |= POLLIN;
			}
			if (conn->want_write) {
				pfd.events |= POLLOUT;
			}
			poll_args.push_back(pfd);
		}

		// Call poll() to wait for events.
		int rv = poll(poll_args.data(), poll_args.size(), -1);
		if (rv < 0 && errno != EINTR) {
			continue; // Not an error, just interrupted by signal.
		}
		if (rv < 0) {
			die("poll()"); // Error.
		}

		// Handle listener socket.
		if(poll_args[0].revents) {
			if(Conn *conn = handle_accept(listen_fd)) {
				if ((size_t)conn->fd >= fd2conn.size()) {
					fd2conn.resize(conn->fd + 1);
				}
				fd2conn[conn->fd] = conn;
			}
		}

		for (size_t i = 1; i < poll_args.size(); i++){ // Skip first entry (Listening socket)
			uint32_t revents = poll_args[i].revents;
			Conn *conn = fd2conn[poll_args[i].fd];
			if (revents & POLLIN) {
				handle_read(conn);  // application logic
			}
			if (revents & POLLOUT) {
				handle_write(conn); // application logic
			}

			// Handle error or close.
			if ((revents & POLLERR) || conn->want_close) {
				close(conn->fd);
				delete conn;
				fd2conn[poll_args[i].fd] = nullptr;
			}
		}

		// // Accept connection.
		// struct sockaddr_in client_addr = {};
		// socklen_t client_addr_len = sizeof(client_addr);
		// int client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);

		// if (client_fd < 0) {
		// 	continue; // error
		// }

		// while (true) {
		// 	int32_t err = one_request(client_fd);
		// 	if (err) {
		//         break;
		//     }
		// }

		// // Close the client connection.
		// close(client_fd);
	}
}
