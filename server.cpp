// stdlib
#include <assert.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
// system
#include <fcntl.h>
#include <poll.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <netinet/ip.h>
// C++
#include <string>
#include <vector>
#include <map>

using namespace std;

const size_t k_max_msg = 4096;
const size_t k_max_args = 200 * 1000;

// Connection state.
struct Conn {
	int fd = -1;
	// application's intention, for the event loop
	bool want_read = false;
	bool want_write = false;
	bool want_close = false;
	// buffered input and output
	std::vector<uint8_t> incoming;  // data to be parsed by the application
	std::vector<uint8_t> outgoing;  // responses generated by the application
};

struct Response {
	uint32_t status = 0;
	std::vector<uint8_t> data;
};

// Response::status
enum {
	RES_OK = 0,
	RES_ERR = 1,    // error
	RES_NX = 2,     // key not found
};

// Error handling functions.
static void die(const char *msg) {
	int err = errno;
	fprintf(stderr, "[%d] %s\n", err, msg);
	abort();
}

// Print a message to stderr.
static void msg(const char *msg) {
	fprintf(stderr, "%s\n", msg);
}

// Set a file descriptor to non-blocking mode.
static void fd_set_nb(int fd) {
	fcntl(fd, F_SETFL, fcntl(fd, F_GETFL, 0) | O_NONBLOCK);
}

// Append to the back of the buffer.
static void
buf_append(std::vector<uint8_t> &buf, const uint8_t *data, size_t len) {
	buf.insert(buf.end(), data, data + len);
}
// Remove from the front of the buffer.
static void buf_consume(std::vector<uint8_t> &buf, size_t n) {
	buf.erase(buf.begin(), buf.begin() + n);
}



// Handle accept.
static Conn *handle_accept(int listen_fd) {
	struct sockaddr_in client_addr = {};
	socklen_t client_addr_len = sizeof(client_addr);
	int client_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);
	if (client_fd < 0) {
		return nullptr; // error
	}

	// Set the client socket to non-blocking mode.
	fd_set_nb(client_fd);

	// Create a new connection state.
	Conn *conn = new Conn();
	conn->fd = client_fd;
	conn->want_read = true; // Read the first request.
	return conn;
}


/// @brief Helper function for reading a 4 byte word from cur (not surpassing end)
/// @param cur Location to read from
/// @param end End of message
/// @param out Desination to read to
static bool read_u32(const uint8_t *&cur, const uint8_t *&end, uint32_t &out){
	if (cur + 4 > end){
		return false; // We tried to read past the end of message
	}
	memcpy(&out, cur, 4); // Read to out
	cur += 4; // Advance the position in the message
	return 1;
}

/// @brief Helper function for reading string of length 'len' from cur
/// @param cur Location to read from
/// @param end End of message
/// @param len Length of message
/// @param out String to read into
static bool read_str(const uint8_t *&cur, const uint8_t *&end, size_t len, string &out) {
	if (cur + len > end){
		return false; //
	}
	out.assign(cur, cur + len); // Read string to out
	cur += len; // Advance the position in the message
	return 1;
}

// Message protocol:
// nstr | len1 | str1 | len2 | str2 | ...
// nstr: Number of strings in the message
// len*: Length of string *
// str*: Actual message string


// Parse a request from the buffer.
static int32_t parse_req(const uint8_t *data, size_t len, std::vector<std::string> &out) {
	const uint8_t *cur = data;
	const uint8_t *end = data + len;

	// Read number of strings
	uint32_t nstr = 0;
	if (!read_u32(cur, end, nstr)) {
		return -1; // Failed to read number of strings.
	}
	if (nstr > k_max_args){
		return -1; // safety limit
	}

	// Reach each individual string
	for (uint32_t i = 0; i < nstr; ++i) {
		// Read string length
		uint32_t slen = 0;
		if (!read_u32(cur, end, slen)) {
			return -1; // Failed to read string length.
		}

		// Read string
		string str;
		if (!read_str(cur, end, slen, str)) {
			return -1; // Failed to read string.
		}

		// Append read string to output
		out.push_back(str);
	}
	if (data != end){
		return -1; //Trailing garbage
	}

	return 0; // Successfully parsed the request.
}

// placeholder; implemented later
static std::map<std::string, std::string> g_data;

static void do_request(std::vector<std::string> &cmd, Response &out) {
	if (cmd.size() == 2 && cmd[0] == "get") {
		// Load requested data
		auto it = g_data.find(cmd[1]);
		if (it == g_data.end()) {
			out.status = RES_NX;    // not found
			return;
		}
		const std::string &val = it->second; // Get the requested value
		out.data.assign(val.begin(), val.end()); // Write value to response
	} else if (cmd.size() == 3 && cmd[0] == "set") {
		g_data[cmd[1]].swap(cmd[2]); // Set (key,value) in the map, overwriting the existing contents
	} else if (cmd.size() == 2 && cmd[0] == "del") {
		g_data.erase(cmd[1]);
	} else {
		out.status = RES_ERR;       // unrecognized command
	}
}


// Try to parse the accumulated buffer.
static bool try_one_request(Conn *conn) {
	// Check if the accumulated buffer has at least 4 bytes, which is the size of the message header.
	if (conn->incoming.size() < 4) {
		return false; 
	}

	uint32_t nstr = 0; //Number of strings
	memcpy(&nstr, conn->incoming.data(), 4);

	// Parse the message header.
	uint32_t len = 0; // Message length.
	memcpy(&len, conn->incoming.data(), 4); // Assume little endian.
	if (len > k_max_msg) { // protocol violation
		msg("too long");
		conn->want_close = true;
		return false; // return with want_close = true
	}

	
	if(4 + len > conn->incoming.size()) {
		return false;
	}

	// Process the parsed message.
	const uint8_t *request = &conn->incoming[4]; // Request body.



	printf("client says: len:%d data:%.*s\n",
		len, len < 100 ? len : 100, request);
	
	// Generate response.
	buf_append(conn->outgoing, (const uint8_t *)&len, 4);
	buf_append(conn->outgoing, request, len);
	// Remove the message from `Conn::incoming`.
	buf_consume(conn->incoming, 4 + len);
	return true;
}

// Handle write.
static void handle_write(Conn *conn) {
	assert(conn->outgoing.size() > 0);

	// Write the response to the client.
	ssize_t rv = write(conn->fd, conn->outgoing.data(), conn->outgoing.size());

	if (rv < 0 && errno == EAGAIN) {
		return; // actually not ready
	}

	if (rv <= 0) {
		conn->want_close = true;
		return; // return with want_close
	}

	// Remove the sent data from the `Conn::outgoing` buffer.
	buf_consume(conn->outgoing, (size_t)rv);

	// If there is no more data to send, set the `want_read` flag.
	if (conn->outgoing.size() == 0) {
		conn->want_read = true;
		conn->want_write = false;
	} // else, keep `want_write` true
}

// Handle read.
static void handle_read(Conn *conn) {
	uint8_t buf[64 * 1024]; // 64 KB buffer
	ssize_t rv = read(conn->fd, buf, sizeof(buf));
	if (rv <= 0) {
		conn->want_close = true;
		return; // return with want_close = true
	}

	// Append the read data to the `Conn::incoming` buffer.
	buf_append(conn->incoming, buf, (size_t)rv);

	while (try_one_request(conn)) {
		// Process as many requests as possible.
	}

	// If there is data to send, set the `want_write` flag.
	if (conn->outgoing.size() > 0) {
		conn->want_read = false;
		conn->want_write = true;

		// The client is likely ready for writing, so we can try to write immediately.
		// This is an optimization to avoid waiting for the next event loop iteration.
		return handle_write(conn);
	} // else, keep `want_read` true
}

// Main function.
int main()
{
	// Define listener socket.
	// AF_INET: IPv4 Internet protocols
	// SOCK_STREAM: TCP - connection-based protocol
	int listen_fd = socket(AF_INET, SOCK_STREAM, 0); // Listener socket file descriptor.
	if (listen_fd < 0) {
		die("socket()");
	}

	// Set the socket option to reuse the address.
	// This allows the server to bind to the same address and port. 
	int val = 1;
	int sockopt_rv = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &val, sizeof(val));
	if (sockopt_rv) {
		die("setsockopt()");
	}


	// Bind the socket to an address and port.
	struct sockaddr_in addr = {}; // IPv4 port pair.
	addr.sin_family = AF_INET;
	addr.sin_port = htons(1234);        // port
	addr.sin_addr.s_addr = htonl(0);    // wildcard IP 0.0.0.0
	int rv = bind(listen_fd, (const struct sockaddr *)&addr, sizeof(addr));
	if (rv) {
		die("bind()");
	}


	// Listen for incoming connections.
	rv = listen(listen_fd, 10);
	if (rv) {
		die("listen()");
	}

	// Since fd is a small integer, we can use a simple vector to map fd to connection state.
	std::vector<Conn *> fd2conn; // map file descriptor to connection state

	// Vector of pollfd structures.
	// Each pollfd structure contains the file descriptor and the events to monitor.
	std::vector<struct pollfd> poll_args;

	// Set the listener socket to non-blocking mode.
	fd_set_nb(listen_fd);
	// Event loop.
	while (true) {

		// Clear the poll_args vector.
		poll_args.clear();

		// Add the listener socket to the poll_args vector.
		struct pollfd listen_pollfd = {listen_fd, POLLIN, 0};
		poll_args.push_back(listen_pollfd);

		// Add the connection sockets to the poll_args vector.
		for(Conn *conn : fd2conn) {
			// Skip connections that are not active.
			if (!conn) {
				continue;
			}
			// Add the connection socket to the poll_args vector.
			struct pollfd pfd = {conn->fd, 0, 0};
			// Monitor the connection socket for read and write events.
			if (conn->want_read) {
				pfd.events |= POLLIN;
			}
			if (conn->want_write) {
				pfd.events |= POLLOUT;
			}
			poll_args.push_back(pfd);
		}

		// Call poll() to wait for events.
		int rv = poll(poll_args.data(), poll_args.size(), -1);
		if (rv < 0 && errno != EINTR) {
			continue; // Not an error, just interrupted by signal.
		}
		if (rv < 0) {
			die("poll()"); // Error.
		}

		// Handle listener socket.
		if(poll_args[0].revents) {
			if(Conn *conn = handle_accept(listen_fd)) {
				if ((size_t)conn->fd >= fd2conn.size()) {
					fd2conn.resize(conn->fd + 1);
				}
				fd2conn[conn->fd] = conn;
			}
		}

		for (size_t i = 1; i < poll_args.size(); i++){ // Skip first entry (Listening socket)
			uint32_t revents = poll_args[i].revents;
			Conn *conn = fd2conn[poll_args[i].fd];
			if (revents & POLLIN) {
				handle_read(conn);  // application logic
			}
			if (revents & POLLOUT) {
				handle_write(conn); // application logic
			}

			// Handle error or close.
			if ((revents & POLLERR) || conn->want_close) {
				if (close(conn->fd) < 0) {
					die("close");
				}
				delete conn;
				fd2conn[poll_args[i].fd] = nullptr;
			}
		}


	}
}
